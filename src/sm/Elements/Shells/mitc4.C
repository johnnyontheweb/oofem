/*
 *
 *                 #####    #####   ######  ######  ###   ###
 *               ##   ##  ##   ##  ##      ##      ## ### ##
 *              ##   ##  ##   ##  ####    ####    ##  #  ##
 *             ##   ##  ##   ##  ##      ##      ##     ##
 *            ##   ##  ##   ##  ##      ##      ##     ##
 *            #####    #####   ##      ######  ##     ##
 *
 *
 *             OOFEM : Object Oriented Finite Element Code
 *
 *               Copyright (C) 1993 - 2013   Borek Patzak
 *
 *
 *
 *       Czech Technical University, Faculty of Civil Engineering,
 *   Department of Structural Mechanics, 166 29 Prague, Czech Republic
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include "sm/Elements/Shells/mitc4.h"
#include "sm/Materials/structuralms.h"
#include "sm/Materials/structuralmaterial.h"
#include "sm/CrossSections/structuralcrosssection.h"
#include "fei2dquadlin.h"
#include "node.h"
#include "material.h"
#include "crosssection.h"
#include "gausspoint.h"
#include "sm/CrossSections/variablecrosssection.h"
#include "gaussintegrationrule.h"
#include "floatmatrix.h"
#include "floatarray.h"
#include "floatmatrixf.h"
#include "floatarrayf.h"
#include "intarray.h"
#include "load.h"
#include "boundaryload.h"
#include "mathfem.h"
#include "classfactory.h"
#include "connectivitytable.h"
#include "angle.h"

namespace oofem {
REGISTER_Element(MITC4Shell);

FEI2dQuadLin MITC4Shell :: interp_lin(1, 2);
IntArray MITC4Shell::shellOrdering = { 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23 };
IntArray MITC4Shell::drillOrdering = { 6, 12, 18, 24 };

MITC4Shell :: MITC4Shell(int n, Domain *aDomain) :
    NLStructuralElement(n, aDomain), ZZNodalRecoveryModelInterface(this),
    SPRNodalRecoveryModelInterface(), SpatialLocalizerInterface(this),
    nPointsXY(4),
    nPointsZ(2)
{
    numberOfDofMans = 4;
    nPointsXY = 4;
    nPointsZ = 2;
    numberOfGaussPoints = nPointsXY * nPointsZ;
	BMatrices.resize(numberOfGaussPoints);
	LMatrices.resize(4);
}


FEInterpolation *
MITC4Shell :: giveInterpolation() const { return & interp_lin; }


FEInterpolation *
MITC4Shell :: giveInterpolation(DofIDItem id) const
{
    return & interp_lin;
}


Interface *
MITC4Shell :: giveInterface(InterfaceType interface)
{
    if ( interface == ZZNodalRecoveryModelInterfaceType ) {
        return static_cast< ZZNodalRecoveryModelInterface * >(this);
    } else if ( interface == SPRNodalRecoveryModelInterfaceType ) {
        return static_cast< SPRNodalRecoveryModelInterface * >(this);
    } else if ( interface == NodalAveragingRecoveryModelInterfaceType ) {
        return static_cast< NodalAveragingRecoveryModelInterface * >(this);
    } else if ( interface == SpatialLocalizerInterfaceType ) {
        return static_cast< SpatialLocalizerInterface * >(this);
    }

    return nullptr;
}


void
MITC4Shell :: SPRNodalRecoveryMI_giveSPRAssemblyPoints(IntArray &pap)
{
    pap.resize(numberOfDofMans);
    for ( int i = 1; i <= numberOfDofMans; i++ ) {
        pap.at(i) = this->giveNode(i)->giveNumber();
    }
}


void
MITC4Shell :: SPRNodalRecoveryMI_giveDofMansDeterminedByPatch(IntArray &answer, int pap)
{
    int found = 0;
    answer.resize(1);

    for ( int i = 1; i <= numberOfDofMans; i++ ) {
        if ( this->giveNode(i)->giveNumber() == pap ) {
            found = 1;
        }
    }

    if ( found ) {
        answer.at(1) = pap;
    } else {
        OOFEM_ERROR("unknown node number %d", pap);
    }
}

int
MITC4Shell :: SPRNodalRecoveryMI_giveNumberOfIP()
{
    return this->giveDefaultIntegrationRulePtr()->giveNumberOfIntegrationPoints();
}


SPRPatchType
MITC4Shell :: SPRNodalRecoveryMI_givePatchType()
{
    return SPRPatchType_3dBiLin;
}


void
MITC4Shell :: computeGaussPoints()
// Sets up the array containing the eight Gauss points of the receiver.
{
    if ( integrationRulesArray.size() == 0 ) {
        integrationRulesArray.resize(1);
        integrationRulesArray [ 0 ] = std::make_unique<GaussIntegrationRule>(1, this, 1, 10);
        this->giveCrossSection()->setupIntegrationPoints(* integrationRulesArray [ 0 ], nPointsXY, nPointsZ, this);
    }
}


std::array<FloatArrayF<3>, 4>
MITC4Shell :: giveDirectorVectors()
{
    if ( directorType == 0 ) { // normal to the midplane
        auto e = this->computeLocalBaseVectors();
        return {e[2], e[2], e[2], e[2]};
    } else if ( directorType == 1 ) {          // nodal average
        int csNum = this->giveCrossSection()->giveNumber();
        std::array<FloatArrayF<3>, 4> directors;

        IntArray neighbours;
        ConnectivityTable *conTable = this->giveDomain()->giveConnectivityTable();
        IntArray node(1);

        for ( int i = 1; i <= 4; i++ ) {
            FloatArrayF<3> nodeDir;
            node.at(1) = this->giveNode(i)->giveNumber();
            conTable->giveNodeNeighbourList(neighbours, node);

            for ( int j = 1; j <= neighbours.giveSize(); j++ ) {
                auto neighbour = dynamic_cast< MITC4Shell * >( this->giveDomain()->giveElement( neighbours.at(j) ) );
                if ( neighbour ) {
                    if ( neighbour->giveCrossSection()->giveNumber() == csNum ) {
                        auto e = neighbour->computeLocalBaseVectors();
                        nodeDir += e[2];
                    }
                }
            }
            directors[i] = normalize(nodeDir);
        }
        return directors;
    } else if ( directorType == 2 ) {          // specified at crosssection
        std::array<FloatArrayF<3>, 4> V;
        for ( int i = 0; i < 4; ++i ) {
            const auto &c = this->giveNode(i+1)->giveCoordinates();
            FloatArrayF<3> v = {
                this->giveCrossSection()->give(CS_DirectorVectorX, c, this, false),
                this->giveCrossSection()->give(CS_DirectorVectorY, c, this, false),
                this->giveCrossSection()->give(CS_DirectorVectorZ, c, this, false),
            };
            V[i] = normalize(v);
        }
        return V;
	} else {
		FloatArray a, b;
		a.add(*this->giveNode(1)->giveCoordinates());
		a.add(*this->giveNode(4)->giveCoordinates());
		a.subtract(*this->giveNode(2)->giveCoordinates());
		a.subtract(*this->giveNode(3)->giveCoordinates());

		b.add(*this->giveNode(1)->giveCoordinates());
		b.add(*this->giveNode(2)->giveCoordinates());
		b.subtract(*this->giveNode(3)->giveCoordinates());
		b.subtract(*this->giveNode(4)->giveCoordinates());

		V1.beVectorProductOf(a, b);
		V1.normalize();

		// should be e3?

		V2 = V1;
		V3 = V1;
		V4 = V1;
	}
}


std::array<FloatArrayF<3>, 4>
MITC4Shell ::  giveLocalDirectorVectors()
{
    auto Vg = this->giveDirectorVectors();
    return {
        dot(GtoLRotationMatrix, Vg[0]),
        dot(GtoLRotationMatrix, Vg[1]),
        dot(GtoLRotationMatrix, Vg[2]),
        dot(GtoLRotationMatrix, Vg[3]),
    };
}

void
MITC4Shell::computeInitialStressMatrix(FloatMatrix &answer, TimeStep *tStep)
{
	answer.resize(24, 24);
	answer.zero();

	// matrix assembly vectors
	IntArray asmz{ 3, 9, 15, 21 };  // local z

	// stress vector
	FloatArray str, str2;
	//this->giveCharacteristicVector(str, InternalForcesVector, VM_Total, tStep);
	for (GaussPoint *gp : *this->giveDefaultIntegrationRulePtr()) {
		this->giveIPValue(str2, gp, IST_ShellForceTensor, tStep);
		str2.times(gp->giveWeight());
		str.add(str2);
	}
	// str.times(2.0); // the weights add up to 0.5 for a tria
	// this needs to be transformed to local
	FloatMatrix strmat{ 3, 3 };
	strmat.at(1, 1) = str.at(1); strmat.at(2, 2) = str.at(2); strmat.at(3, 3) = str.at(3);
	strmat.at(1, 2) = str.at(6); strmat.at(1, 3) = str.at(5); strmat.at(2, 3) = str.at(4);
	strmat.symmetrized();
	strmat.rotatedWith(*this->computeGtoLRotationMatrix(), 't'); // back to local

	// if above are local and Forces by unit length
	// first average them
	double sx = 0, sy = 0, sxy = 0;
	//for (auto it : asm1) sx += str.at(it);
	//for (auto it : asm2) sy += str.at(it);
	//for (auto it : asm3) sxy += str.at(it);
	//sx = str.at(1);
	//sy = str.at(2);
	//sxy = str.at(6);
	sx = strmat.at(1, 1);
	sy = strmat.at(2, 2);
	sxy = strmat.at(1, 2);

	// partial matrices
	FloatMatrix Kgx{ 4, 4 }, Kgy{ 4, 4 }, Kgxy{ 4, 4 };

	// calculate the matrices - hp constant thickness
	double x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4;
	this->giveNodeCoordinates(x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4);
	FloatArray n1{ x1, y1, z1 }, n2{ x2, y2, z2 }, n3{ x3, y3, z3 }, n4{ x4, y4, z4 };
	// then divide
	double a1 = n1.distance(n2); double a2 = n4.distance(n3);
	double a = 0.25*(a1 + a2);
	double b1 = n2.distance(n3); double b2 = n1.distance(n4);
	double b = 0.25*(b1 + b2);
	sx /= (6 * a/b);
	sy /= (6 * b/a);
	sxy /= (2);

	Kgx.at(1, 1) = 2; Kgx.at(2, 2) = 2; Kgx.at(3, 3) = 2; Kgx.at(4, 4) = 2;
	Kgx.at(1, 2) = -2; Kgx.at(1, 3) = -1; Kgx.at(1, 4) = 1;
	Kgx.at(2, 3) = 1; Kgx.at(2, 4) = -1; Kgx.at(3, 4) = -2;

	Kgy.at(1, 1) = 2; Kgy.at(2, 2) = 2; Kgy.at(3, 3) = 2; Kgy.at(4, 4) = 2;
	Kgy.at(1, 2) = 1; Kgy.at(1, 3) = -1; Kgy.at(1, 4) = -2;
	Kgy.at(2, 3) = -2; Kgy.at(2, 4) = -1; Kgy.at(3, 4) = 1;

	Kgxy.at(1, 1) = 1; Kgxy.at(2, 2) = -1; Kgxy.at(3, 3) = 1; Kgxy.at(4, 4) = -1;
	Kgxy.at(1, 2) = 0; Kgxy.at(1, 3) = -1; Kgxy.at(1, 4) = 0;
	Kgxy.at(2, 3) = 0; Kgxy.at(2, 4) = 1; Kgxy.at(3, 4) = 0;

	Kgx.symmetrized(); Kgy.symmetrized(); Kgxy.symmetrized();

	// assemble them
	Kgx.times(sx);
	Kgx.add(sy, Kgy);
	Kgx.add(sxy, Kgxy);
	// once for local z
	answer.assemble(Kgx, asmz);
	// done
}

double
MITC4Shell::computeArea()
// returns the area occupied by the receiver
{
	// get node coordinates
	double x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4;
	this->giveNodeCoordinates(x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4);

	return 0.5*(x2*y3 + x1*y2 + y1*x3 - x2*y1 - x3*y2 - x1*y3) + 0.5*(x3*y4 + x1*y3 + y1*x4 - x3*y1 - x4*y3 - x1*y4);
}

void
MITC4Shell :: computeNmatrixAt(const FloatArray &iLocCoord, FloatMatrix &answer)
// Returns the [6x24] displacement interpolation matrix {N} of the receiver,
// evaluated at gp.
// Zeroes in rows 4, 5, 6.
{
    auto h = interp_lin.evalN(FloatArrayF<3>(iLocCoord)[{0, 1}]);
    auto a = this->giveThickness();
    auto V = this->giveLocalDirectorVectors();
	answer.resize(6, 24);
	answer.zero();

	//if (NMatrix.get() != nullptr) {
	//	answer.add(*NMatrix);
	//	return;
	//}

    FloatArray h(4);
    FloatArrayF<3> e2 = {0., 1., 0.};

    answer.resize(6, 6 * 4);
    answer.zero();
    for ( int i = 0; i < 4; ++i ) {
        auto Ve = normalize(cross(e2, V[i]));
        auto VVe = cross(V[i], Ve);
        answer.at(1, 1+i*6) = answer.at(2, 2+i*6) = answer.at(3, 3+i*6) = h[i];
        answer.at(1, 4+i*6) = -iLocCoord.at(3) / 2.0 * a[i] * h[i] * VVe.at(1);
        answer.at(1, 5+i*6) =  iLocCoord.at(3) / 2.0 * a[i] * h[i] * Ve.at(1);
        answer.at(2, 4+i*6) = -iLocCoord.at(3) / 2.0 * a[i] * h[i] * VVe.at(2);
        answer.at(2, 5+i*6) =  iLocCoord.at(3) / 2.0 * a[i] * h[i] * Ve.at(2);
        answer.at(3, 4+i*6) = -iLocCoord.at(3) / 2.0 * a[i] * h[i] * VVe.at(3);
        answer.at(3, 5+i*6) =  iLocCoord.at(3) / 2.0 * a[i] * h[i] * Ve.at(3);

	//NMatrix.reset(new FloatMatrix(answer));
}
}


void
MITC4Shell :: computeConstitutiveMatrixAt(FloatMatrix &answer, MatResponseMode rMode, GaussPoint *gp, TimeStep *tStep)
{
    auto scs = dynamic_cast< StructuralCrossSection * >( this->giveCrossSection() );
    //auto cs = dynamic_cast< SimpleCrossSection * >( this->giveCrossSection() );
    answer = scs->give3dDegeneratedShellStiffMtrx(rMode, gp, tStep);
}


std::array<FloatArrayF<3>, 4>
MITC4Shell :: giveNodeCoordinates()
{
    std::array<FloatArrayF<3>, 4> c;
    for (int i = 0; i < 4; ++i) {
        c[i] = this->giveLocalCoordinates(this->giveNode(i+1)->giveCoordinates());
    }
    return c;
}

FloatArrayF<3>
MITC4Shell :: giveLocalCoordinates(const FloatArrayF<3> &global)
{
    auto offset = global - FloatArrayF<3>(this->giveNode(1)->giveCoordinates());
    return dot(GtoLRotationMatrix, offset);
}

void
MITC4Shell :: initializeFrom(InputRecord &ir)
{
    NLStructuralElement :: initializeFrom(ir);
    // test the parametr
    if ( global.giveSize() != 3 ) {
        OOFEM_ERROR("cannot transform coordinates - size mismatch");
        exit(1);
    }

    IR_GIVE_OPTIONAL_FIELD(ir, nPointsXY, _IFT_Element_nip);
    IR_GIVE_OPTIONAL_FIELD(ir, nPointsZ, _IFT_MITC4Shell_nipZ);
    IR_GIVE_OPTIONAL_FIELD(ir, nlGeometry, _IFT_NLStructuralElement_nlgeoflag);

    directorType = 0; // default
    IR_GIVE_OPTIONAL_FIELD(ir, directorType, _IFT_MITC4Shell_directorType);
    offset = global;
    offset.subtract( * this->giveNode(1)->giveCoordinates() );
    answer.beProductOf(GtoLRotationMatrix, offset);
}

<<<<<<< .mine
IRResultType
MITC4Shell :: initializeFrom(InputRecord *ir)
{
    IRResultType result;                   // Required by IR_GIVE_FIELD macro

    IR_GIVE_OPTIONAL_FIELD(ir, nPointsXY, _IFT_Element_nip);
    IR_GIVE_OPTIONAL_FIELD(ir, nPointsZ, _IFT_MITC4Shell_nipZ);
    IR_GIVE_OPTIONAL_FIELD(ir, nlGeometry, _IFT_NLStructuralElement_nlgeoflag);

	// optional record for 1st local axes
	la1.resize(3);
	la1.at(1) = 0; la1.at(2) = 0; la1.at(3) = 0;
	IR_GIVE_OPTIONAL_FIELD(ir, la1, _IFT_MITC4Shell_FirstLocalAxis);

	this->macroElem = 0;
	IR_GIVE_OPTIONAL_FIELD(ir, this->macroElem, _IFT_MITC4Shell_macroElem);

    return this->NLStructuralElement :: initializeFrom(ir);
}


=======





















>>>>>>> .theirs
void
MITC4Shell :: giveDofManDofIDMask(int inode, IntArray &answer) const
{
    answer = {
        D_u, D_v, D_w, R_u, R_v, R_w
    };
}

double
MITC4Shell :: computeVolumeAround(GaussPoint *gp)
{
    FloatArrayF<3> lcoords = {
        gp->giveNaturalCoordinate(1),
        gp->giveNaturalCoordinate(2),
        gp->giveNaturalCoordinate(3),
    };

    auto jacobianMatrix = this->giveJacobian(lcoords);
    return det(jacobianMatrix) * gp->giveWeight();
}


<<<<<<< .mine
    this->giveJacobian(lcoords, jacobianMatrix);






=======
FloatMatrixF<3,3>
MITC4Shell :: giveJacobian(const FloatArrayF<3> &lcoords)
{
    // derivatives of interpolation functions
    auto dn = interp_lin.evaldNdxi(lcoords[{0, 1}]);
    auto hk1 = dn.row<0>(); // dh(r1,r2)/dr1
    auto hk2 = dn.row<1>(); // dh(r1,r2)/dr2
>>>>>>> .theirs

    // interpolation functions - h(r1,r2)
    //auto [h1, h2, h3, h4] = interp_lin.evalN(lcoords[{0, 1}]);
    auto h = interp_lin.evalN(lcoords[{0, 1}]);
    double h1 = h[0];
    double h2 = h[1];
    double h3 = h[2];
    double h4 = h[3];

    //auto [a1, a2, a3, a4] = this->giveThickness();
    auto a = this->giveThickness();
    double a1 = a[0];
    double a2 = a[1];
    double a3 = a[2];
    double a4 = a[3];

<<<<<<< .mine
void
MITC4Shell :: giveJacobian(FloatArray lcoords, FloatMatrix &jacobianMatrix)
// Returns the jacobianMatrix
{
    FloatArray h(4);
    FloatMatrix dn(4, 2);
    FloatMatrix dndx(4, 2);

    jacobianMatrix.resize(3, 3);
=======









>>>>>>> .theirs
    // get node coordinates
<<<<<<< .mine
    double x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4;
    this->giveNodeCoordinates(x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4);

=======



>>>>>>> .theirs
    double r3 = lcoords.at(3);
    auto c = this->giveNodeCoordinates();
    //auto [x1, y1, z1] = c[0];
    //auto [x2, y2, z2] = c[1];
    //auto [x3, y3, z3] = c[2];
    //auto [x4, y4, z4] = c[3];
    double x1 = c[0][0], y1 = c[0][1];
    double x2 = c[1][0], y2 = c[1][1];
    double x3 = c[2][0], y3 = c[2][1];
    double x4 = c[3][0], y4 = c[3][1];

    //auto [V1, V2, V3, V4] = this->giveLocalDirectorVectors();
    auto V = this->giveLocalDirectorVectors();
    auto V1 = V[0], V2 = V[1], V3 = V[2], V4 = V[3];

<<<<<<< .mine
    // get thickness
    double a1, a2, a3, a4;
    this->giveThickness(a1, a2, a3, a4);

    interp_lin.evalN( h, lcoords,  FEIElementGeometryWrapper(this) );
    interp_lin.giveDerivatives(dn, lcoords);

    FloatArray hk1(4);
    // derivatives of interpolation functions
    // dh(r1,r2)/dr1
    hk1.at(1) =  dn.at(1, 1);
    hk1.at(2) =  dn.at(2, 1);
    hk1.at(3) =  dn.at(3, 1);
    hk1.at(4) =  dn.at(4, 1);

    FloatArray hk2(4);
    // dh(r1,r2)/dr2
    hk2.at(1) =  dn.at(1, 2);
    hk2.at(2) =  dn.at(2, 2);
    hk2.at(3) =  dn.at(3, 2);
    hk2.at(4) =  dn.at(4, 2);

    double h1, h2, h3, h4;
    // interpolation functions - h(r1,r2)
    h1 = h.at(1);
    h2 = h.at(2);
    h3 = h.at(3);
    h4 = h.at(4);

=======





























>>>>>>> .theirs
    // Jacobian Matrix
    FloatMatrixF<3,3> jacobianMatrix;
    jacobianMatrix.at(1, 1) = hk1.at(1) * x1 + hk1.at(2) * x2 + hk1.at(3) * x3 + hk1.at(4) * x4 + r3 / 2. * ( a1 * hk1.at(1) * V1.at(1) + a2 * hk1.at(2) * V2.at(1) + a3 * hk1.at(3) * V3.at(1) + a4 * hk1.at(4) * V4.at(1) );
    jacobianMatrix.at(1, 2) = hk1.at(1) * y1 + hk1.at(2) * y2 + hk1.at(3) * y3 + hk1.at(4) * y4 + r3 / 2. * ( a1 * hk1.at(1) * V1.at(2) + a2 * hk1.at(2) * V2.at(2) + a3 * hk1.at(3) * V3.at(2) + a4 * hk1.at(4) * V4.at(2) );
    jacobianMatrix.at(1, 3) = r3 / 2. * ( a1 * hk1.at(1) * V1.at(3) + a2 * hk1.at(2) * V2.at(3) + a3 * hk1.at(3) * V3.at(3) + a4 * hk1.at(4) * V4.at(3) );
    jacobianMatrix.at(2, 1) = hk2.at(1) * x1 + hk2.at(2) * x2 + hk2.at(3) * x3 + hk2.at(4) * x4 + r3 / 2. * ( a1 * hk2.at(1) * V1.at(1) + a2 * hk2.at(2) * V2.at(1) + a3 * hk2.at(3) * V3.at(1) + a4 * hk2.at(4) * V4.at(1) );
    jacobianMatrix.at(2, 2) = hk2.at(1) * y1 + hk2.at(2) * y2 + hk2.at(3) * y3 + hk2.at(4) * y4 + r3 / 2. * ( a1 * hk2.at(1) * V1.at(2) + a2 * hk2.at(2) * V2.at(2) + a3 * hk2.at(3) * V3.at(2) + a4 * hk2.at(4) * V4.at(2) );
    jacobianMatrix.at(2, 3) = r3 / 2. * ( a1 * hk2.at(1) * V1.at(3) + a2 * hk2.at(2) * V2.at(3) + a3 * hk2.at(3) * V3.at(3) + a4 * hk2.at(4) * V4.at(3) );
    jacobianMatrix.at(3, 1) =  1. / 2. * ( a1 * h1 * V1.at(1) + a2 * h2 * V2.at(1) + a3 * h3 * V3.at(1) + a4 * h4 * V4.at(1) );
    jacobianMatrix.at(3, 2) =  1. / 2. * ( a1 * h1 * V1.at(2) + a2 * h2 * V2.at(2) + a3 * h3 * V3.at(2) + a4 * h4 * V4.at(2) );
    jacobianMatrix.at(3, 3) =  1. / 2. * ( a1 * h1 * V1.at(3) + a2 * h2 * V2.at(3) + a3 * h3 * V3.at(3) + a4 * h4 * V4.at(3) );
    return jacobianMatrix;
}

void
MITC4Shell :: computeStiffnessMatrix(FloatMatrix &answer, MatResponseMode rMode, TimeStep *tStep)
{
    // This element adds an additional stiffness for the so called drilling dofs.
    NLStructuralElement :: computeStiffnessMatrix(answer, rMode, tStep);

    bool drillType = this->giveStructuralCrossSection()->give( CS_DrillingType, this->giveDefaultIntegrationRulePtr()->getIntegrationPoint(0) );
    if ( drillType == 1 ) {
        double relDrillCoeff = this->giveStructuralCrossSection()->give( CS_RelDrillingStiffness, this->giveDefaultIntegrationRulePtr()->getIntegrationPoint(0) );
        if ( relDrillCoeff == 0.0 ) {
            relDrillCoeff = 0.001; // default
        }

        int j = 1;
        while ( answer.at(j, j) == 0 ) {
            j++;
        }
        drillCoeff = answer.at(j, j);
        // find the smallest non-zero number on the diagonal
        for ( int i = j; i <= 24; i++ ) {
            if ( drillCoeff > answer.at(i, i) && answer.at(i, i) != 0 ) {
                drillCoeff = answer.at(i, i);
            }
        }

        drillCoeff *= relDrillCoeff;

        IntArray drillDofs = {6, 12, 18, 24};
        auto drillStiffness = eye<4>() * drillCoeff;
#if 0
        FloatMatrix drillStiffness;
        for ( auto &gp : *integrationRulesArray [ 0 ] ) {
            double dV = this->computeVolumeAround(gp);
            // double drillCoeff = this->giveStructuralCrossSection()->give(CS_DrillingStiffness, gp);
            double coeff = drillCoeff;
            if ( this->giveStructuralCrossSection()->give(CS_DrillingStiffness, gp)> 0)
                drillCoeff *= this->giveStructuralCrossSection()->give(CS_DrillingStiffness, gp);
            // Drilling stiffness is here for improved numerical properties
            this->interp_lin.evalN( n, gp->giveNaturalCoordinates(), FEIVoidCellGeometry() );
            for ( int j = 0; j < 4; j++ ) {
                n[j] -= 0.25;
            }
            drillStiffness.plusDyadSymmUpper(n, coeff * dV);
        }
        drillStiffness.symmetrized();
#endif
        answer.assemble(drillStiffness, drillDofs);
    }
}

void
MITC4Shell :: giveInternalForcesVector(FloatArray &answer, TimeStep *tStep, int useUpdatedGpRecord)
{
<<<<<<< .mine
	answer.resize(6, 24);
	answer.zero();
	if (BMatrices.at(gp->giveNumber()-1).get() != nullptr) {
		answer.add(*BMatrices.at(gp->giveNumber() - 1));
		return;
	}
    FloatArray h(4);
    FloatMatrix jacobianMatrix(3, 3);
    FloatMatrix dn(4, 2);
    FloatMatrix dndx(4, 2);
=======
    // This element adds an additional stiffness for the so called drilling dofs.
    NLStructuralElement :: giveInternalForcesVector(answer, tStep, useUpdatedGpRecord);








>>>>>>> .theirs

<<<<<<< .mine
    // get node coordinates
    double x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4;
    this->giveNodeCoordinates(x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4);
=======
    bool drillType = this->giveStructuralCrossSection()->give( CS_DrillingType, this->giveDefaultIntegrationRulePtr()->getIntegrationPoint(0) );


>>>>>>> .theirs

    if ( drillType == 1 ) {
        FloatArray n, tmp;
        FloatArray drillUnknowns, drillMoment;
        IntArray drillDofs = {
            6, 12, 18, 24
        };
        this->computeVectorOf(VM_Total, tStep, tmp);
        drillUnknowns.beSubArrayOf(tmp, drillDofs);

#if 0
        for ( auto &gp : *integrationRulesArray [ 0 ] ) {
            double dV = this->computeVolumeAround(gp);
            // double drillCoeff = this->giveStructuralCrossSection()->give(CS_DrillingStiffness, gp);
            double coeff = drillCoeff;
            if ( this->giveStructuralCrossSection()->give(CS_DrillingStiffness, gp)> 0)
                drillCoeff *= this->giveStructuralCrossSection()->give(CS_DrillingStiffness, gp);

            this->interp_lin.evalN( n, gp->giveNaturalCoordinates(), FEIVoidCellGeometry() );
            for ( int j = 0; j < 4; j++ ) {
                n[j] -= 0.25;
            }
            double dtheta = n.dotProduct(drillUnknowns);
            drillMoment.add(coeff * dV * dtheta, n);
         }
#endif

        FloatMatrix drillStiffness;
        drillStiffness.resize(4, 4);
        drillStiffness.zero();
        for ( int i = 1; i <= 4; i++ ) {
            drillStiffness.at(i, i) = drillCoeff;
        }

<<<<<<< .mine
    interp_lin.evalN( h, lcoords,  FEIElementGeometryWrapper(this) );
    interp_lin.giveDerivatives(dn, lcoords);
=======
        drillMoment.beProductOf(drillStiffness, drillUnknowns);

>>>>>>> .theirs

<<<<<<< .mine
    FloatArray hkx, hky;
    this->givedNdx(hkx, hky, lcoords);

=======
        answer.assemble(drillMoment, drillDofs);
    }
}
>>>>>>> .theirs

void
MITC4Shell :: computeBmatrixAt(GaussPoint *gp, FloatMatrix &answer, int li, int ui)
// Returns the [6x20] strain-displacement matrix {B} of the receiver,
// evaluated at gp.
{
    //auto [c1, c2, c3, c4] = this->giveNodeCoordinates();
    auto c = this->giveNodeCoordinates();
    auto c1 = c[0], c2 = c[1], c3 = c[2], c4 = c[3];
<<<<<<< .mine
    this->giveJacobian(lcoords, jacobianMatrix);





=======

    double r1 = gp->giveNaturalCoordinate(1);
    double r2 = gp->giveNaturalCoordinate(2);
    double r3 = gp->giveNaturalCoordinate(3);
    FloatArrayF<3> lcoords = {r1, r2, r3};

>>>>>>> .theirs
    //auto [a1, a2, a3, a4] = this->giveThickness();
    auto a = this->giveThickness();
    double a1 = a[0], a2 = a[1], a3 = a[2], a4 = a[3];

<<<<<<< .mine














=======
    //auto h = interp_lin.evalN(lcoords);
    //auto dn = interp_lin.evaldNdxi(lcoords);

    //auto [hkx, hky] = this->givedNdx(lcoords);
    auto hk = this->givedNdx(lcoords);
    auto hkx = hk[0], hky = hk[1];

    auto J = this->giveJacobian(lcoords);
    auto invJ = inv(J);
    double sb = 2 * invJ.at(1, 1) * invJ.at(3, 3);
    double sa = 2 * invJ.at(1, 2) * invJ.at(3, 3);
    double cb = 2 * invJ.at(2, 1) * invJ.at(3, 3);
    double ca = 2 * invJ.at(2, 2) * invJ.at(3, 3);

>>>>>>> .theirs
    //auto [V1, V2, V3, V4] = this->giveLocalDirectorVectors();
    auto V = this->giveLocalDirectorVectors();
    auto V1 = V[0], V2 = V[1], V3 = V[2], V4 = V[3];

    FloatArrayF<3> e2 = {0., 1., 0.};

    auto V11 = normalize(cross(e2, V1));
    auto V12 = normalize(cross(e2, V2));
    auto V13 = normalize(cross(e2, V3));
    auto V14 = normalize(cross(e2, V4));

    auto V21 = cross(V1, V11);
    auto V22 = cross(V2, V12);
    auto V23 = cross(V3, V13);
    auto V24 = cross(V4, V14);

    answer.resize(6, 24);
    answer.zero();

    answer.at(4, 1) = 1. / 32. * ( ( a1 * V1.at(1) + a2 * V2.at(1) ) * ( cb * ( 1. + r2 ) ) + ( a1 * V1.at(1) + a4 * V4.at(1) ) * ( ca * ( 1. + r1 ) ) );
    answer.at(4, 2) = 1. / 32. * ( ( a1 * V1.at(2) + a2 * V2.at(2) ) * ( cb * ( 1. + r2 ) ) + ( a1 * V1.at(2) + a4 * V4.at(2) ) * ( ca * ( 1. + r1 ) ) );
    answer.at(4, 3) = 1. / 32. * ( ( a1 * V1.at(3) + a2 * V2.at(3) ) * ( cb * ( 1. + r2 ) ) + ( a1 * V1.at(3) + a4 * V4.at(3) ) * ( ca * ( 1. + r1 ) ) );
    answer.at(4, 4) = -a1 / 32. * ( ( dot(V21, c1 - c2) * ( cb * ( 1. + r2 ) ) ) + ( dot(V21, c1 - c4) * ( ca * ( 1. + r1 ) ) ) );
    answer.at(4, 5) = a1 / 32. * ( ( dot(V11, c1 - c2) * ( cb * ( 1. + r2 ) ) ) + ( dot(V11, c1 - c4) * ( ca * ( 1. + r1 ) ) ) );

    answer.at(4, 7) = 1. / 32. * ( -( a1 * V1.at(1) + a2 * V2.at(1) ) * ( cb * ( 1. + r2 ) ) + ( a2 * V2.at(1) + a3 * V3.at(1) ) * ( ca * ( 1. - r1 ) ) );
    answer.at(4, 8) = 1. / 32. * ( -( a1 * V1.at(2) + a2 * V2.at(2) ) * ( cb * ( 1. + r2 ) ) + ( a2 * V2.at(2) + a3 * V3.at(2) ) * ( ca * ( 1. - r1 ) ) );
    answer.at(4, 9) = 1. / 32. * ( -( a1 * V1.at(3) + a2 * V2.at(3) ) * ( cb * ( 1. + r2 ) ) + ( a2 * V2.at(3) + a3 * V3.at(3) ) * ( ca * ( 1. - r1 ) ) );
    answer.at(4, 10) = -a1 / 32. * ( ( dot(V21, c1 - c2) * ( cb * ( 1. + r2 ) ) ) + ( dot(V21, c2 - c3) * ( ca * ( 1. - r1 ) ) ) );
    answer.at(4, 11) = a1 / 32. * ( ( dot(V11, c1 - c2) * ( cb * ( 1. + r2 ) ) ) + ( dot(V11, c2 - c3) * ( ca * ( 1. - r1 ) ) ) );

    answer.at(4, 13) = 1. / 32. * ( -( a3 * V3.at(1) + a4 * V4.at(1) ) * ( cb * ( 1. - r2 ) ) - ( a2 * V2.at(1) + a3 * V3.at(1) ) * ( ca * ( 1. - r1 ) ) );
    answer.at(4, 14) = 1. / 32. * ( -( a3 * V3.at(2) + a4 * V4.at(2) ) * ( cb * ( 1. - r2 ) ) - ( a2 * V2.at(2) + a3 * V3.at(2) ) * ( ca * ( 1. - r1 ) ) );
    answer.at(4, 15) = 1. / 32. * ( -( a3 * V3.at(3) + a4 * V4.at(3) ) * ( cb * ( 1. - r2 ) ) - ( a2 * V2.at(3) + a3 * V3.at(3) ) * ( ca * ( 1. - r1 ) ) );
    answer.at(4, 16) = -a1 / 32. * ( ( dot(V21, c4 - c3) * ( cb * ( 1. - r2 ) ) ) + ( dot(V21, c2 - c3) * ( ca * ( 1. - r1 ) ) ) );
    answer.at(4, 17) = a1 / 32. * ( ( dot(V11, c4 - c3) * ( cb * ( 1. - r2 ) ) ) + ( dot(V11, c2 - c3) * ( ca * ( 1. - r1 ) ) ) );

    answer.at(4, 19) = 1. / 32. * ( ( a3 * V3.at(1) + a4 * V4.at(1) ) * ( cb * ( 1. - r2 ) ) - ( a1 * V1.at(1) + a4 * V4.at(1) ) * ( ca * ( 1. + r1 ) ) );
    answer.at(4, 20) = 1. / 32. * ( ( a3 * V3.at(2) + a4 * V4.at(2) ) * ( cb * ( 1. - r2 ) ) - ( a1 * V1.at(2) + a4 * V4.at(2) ) * ( ca * ( 1. + r1 ) ) );
    answer.at(4, 21) = 1. / 32. * ( ( a3 * V3.at(3) + a4 * V4.at(3) ) * ( cb * ( 1. - r2 ) ) - ( a1 * V1.at(3) + a4 * V4.at(3) ) * ( ca * ( 1. + r1 ) ) );
    answer.at(4, 22) = -a1 / 32. * ( ( dot(V21, c4 - c3) * ( cb * ( 1. - r2 ) ) ) + ( dot(V21, c1 - c4) * ( ca * ( 1. + r1 ) ) ) );
    answer.at(4, 23) = a1 / 32. * ( ( dot(V11, c4 - c3) * ( cb * ( 1. - r2 ) ) ) + ( dot(V11, c1 - c4) * ( ca * ( 1. + r1 ) ) ) );

    answer.at(5, 1) = 1. / 32. * ( ( a1 * V1.at(1) + a2 * V2.at(1) ) * ( sb * ( 1. + r2 ) ) + ( a1 * V1.at(1) + a4 * V4.at(1) ) * ( sa * ( 1. + r1 ) ) );
    answer.at(5, 2) = 1. / 32. * ( ( a1 * V1.at(2) + a2 * V2.at(2) ) * ( sb * ( 1. + r2 ) ) + ( a1 * V1.at(2) + a4 * V4.at(2) ) * ( sa * ( 1. + r1 ) ) );
    answer.at(5, 3) = 1. / 32. * ( ( a1 * V1.at(3) + a2 * V2.at(3) ) * ( sb * ( 1. + r2 ) ) + ( a1 * V1.at(3) + a4 * V4.at(3) ) * ( sa * ( 1. + r1 ) ) );
    answer.at(5, 4) = -a1 / 32. * ( ( dot(V21, c1 - c2) * ( sb * ( 1. + r2 ) ) ) + ( dot(V21, c1 - c4) * ( sa * ( 1. + r1 ) ) ) );
    answer.at(5, 5) = a1 / 32. * ( ( dot(V11, c1 - c2) * ( sb * ( 1. + r2 ) ) ) + ( dot(V11, c1 - c4) * ( sa * ( 1. + r1 ) ) ) );

    answer.at(5, 7) = 1. / 32. * ( -( a1 * V1.at(1) + a2 * V2.at(1) ) * ( sb * ( 1. + r2 ) ) + ( a2 * V2.at(1) + a3 * V3.at(1) ) * ( sa * ( 1. - r1 ) ) );
    answer.at(5, 8) = 1. / 32. * ( -( a1 * V1.at(2) + a2 * V2.at(2) ) * ( sb * ( 1. + r2 ) ) + ( a2 * V2.at(2) + a3 * V3.at(2) ) * ( sa * ( 1. - r1 ) ) );
    answer.at(5, 9) = 1. / 32. * ( -( a1 * V1.at(3) + a2 * V2.at(3) ) * ( sb * ( 1. + r2 ) ) + ( a2 * V2.at(3) + a3 * V3.at(3) ) * ( sa * ( 1. - r1 ) ) );
    answer.at(5, 10) = -a1 / 32. * ( ( dot(V21, c1 - c2) * ( sb * ( 1. + r2 ) ) ) + ( dot(V21, c2 - c3) * ( sa * ( 1. - r1 ) ) ) );
    answer.at(5, 11) = a1 / 32. * ( ( dot(V11, c1 - c2) * ( sb * ( 1. + r2 ) ) ) + ( dot(V11, c2 - c3) * ( sa * ( 1. - r1 ) ) ) );

    answer.at(5, 13) = 1. / 32. * ( -( a3 * V3.at(1) + a4 * V4.at(1) ) * ( sb * ( 1. - r2 ) ) - ( a2 * V2.at(1) + a3 * V3.at(1) ) * ( sa * ( 1. - r1 ) ) );
    answer.at(5, 14) = 1. / 32. * ( -( a3 * V3.at(2) + a4 * V4.at(2) ) * ( sb * ( 1. - r2 ) ) - ( a2 * V2.at(2) + a3 * V3.at(2) ) * ( sa * ( 1. - r1 ) ) );
    answer.at(5, 15) = 1. / 32. * ( -( a3 * V3.at(3) + a4 * V4.at(3) ) * ( sb * ( 1. - r2 ) ) - ( a2 * V2.at(3) + a3 * V3.at(3) ) * ( sa * ( 1. - r1 ) ) );
    answer.at(5, 16) = -a1 / 32. * ( ( dot(V21, c4 - c3) * ( sb * ( 1. - r2 ) ) ) + ( dot(V21, c2 - c3) * ( sa * ( 1. - r1 ) ) ) );
    answer.at(5, 17) = a1 / 32. * ( ( dot(V11, c4 - c3) * ( sb * ( 1. - r2 ) ) ) + ( dot(V11, c2 - c3) * ( sa * ( 1. - r1 ) ) ) );

    answer.at(5, 19) = 1. / 32. * ( ( a3 * V3.at(1) + a4 * V4.at(1) ) * ( sb * ( 1. - r2 ) ) - ( a1 * V1.at(1) + a4 * V4.at(1) ) * ( sa * ( 1. + r1 ) ) );
    answer.at(5, 20) = 1. / 32. * ( ( a3 * V3.at(2) + a4 * V4.at(2) ) * ( sb * ( 1. - r2 ) ) - ( a1 * V1.at(2) + a4 * V4.at(2) ) * ( sa * ( 1. + r1 ) ) );
    answer.at(5, 21) = 1. / 32. * ( ( a3 * V3.at(3) + a4 * V4.at(3) ) * ( sb * ( 1. - r2 ) ) - ( a1 * V1.at(3) + a4 * V4.at(3) ) * ( sa * ( 1. + r1 ) ) );
    answer.at(5, 22) = -a1 / 32. * ( ( dot(V21, c4 - c3) * ( sb * ( 1. - r2 ) ) ) + ( dot(V21, c1 - c4) * ( sa * ( 1. + r1 ) ) ) );
    answer.at(5, 23) = a1 / 32. * ( ( dot(V11, c4 - c3) * ( sb * ( 1. - r2 ) ) ) + ( dot(V11, c1 - c4) * ( sa * ( 1. + r1 ) ) ) );

    answer.at(1, 1) = hkx.at(1);
    answer.at(1, 4) = -r3 / 2. *a1 *hkx.at(1) * V21.at(1);
    answer.at(1, 5) = r3 / 2. *a1 *hkx.at(1) * V11.at(1);

    answer.at(1, 7) = hkx.at(2);
    answer.at(1, 10) = -r3 / 2. *a2 *hkx.at(2) * V22.at(1);
    answer.at(1, 11) = r3 / 2. *a2 *hkx.at(2) * V12.at(1);

    answer.at(1, 13) =  hkx.at(3);
    answer.at(1, 16) = -r3 / 2. *a3 *hkx.at(3) * V23.at(1);
    answer.at(1, 17) = r3 / 2. *a3 *hkx.at(3) * V13.at(1);

    answer.at(1, 19) = hkx.at(4);
    answer.at(1, 22) = -r3 / 2. *a4 *hkx.at(4) * V24.at(1);
    answer.at(1, 23) = r3 / 2. *a4 *hkx.at(4) * V14.at(1);

    answer.at(2, 2) = hky.at(1);
    answer.at(2, 4) = -r3 / 2. *a1 *hky.at(1) * V21.at(2);
    answer.at(2, 5) = r3 / 2. *a1 *hky.at(1) * V11.at(2);

    answer.at(2, 8) = hky.at(2);
    answer.at(2, 10) = -r3 / 2. *a2 *hky.at(2) * V22.at(2);
    answer.at(2, 11) = r3 / 2. *a2 *hky.at(2) * V12.at(2);

    answer.at(2, 14) = hky.at(3);
    answer.at(2, 16) = -r3 / 2. *a3 *hky.at(3) * V23.at(2);
    answer.at(2, 17) = r3 / 2. *a3 *hky.at(3) * V13.at(2);

    answer.at(2, 20) = hky.at(4);
    answer.at(2, 22) = -r3 / 2. *a4 *hky.at(4) * V24.at(2);
    answer.at(2, 23) = r3 / 2. *a4 *hky.at(4) * V14.at(2);

    answer.at(6, 1) = hky.at(1);
    answer.at(6, 2) = hkx.at(1);
    answer.at(6, 4) = -r3 / 2. * a1 * ( hkx.at(1) * V21.at(2) + hky.at(1) * V21.at(1) );
    answer.at(6, 5) = r3 / 2. * a1 * ( hky.at(1) * V11.at(1) + hky.at(1) * V11.at(2) );

    answer.at(6, 7) = hky.at(2);
    answer.at(6, 8) = hkx.at(2);
    answer.at(6, 10) = -r3 / 2. * a2 * ( hkx.at(2) * V22.at(2) + hky.at(2) * V22.at(1) );
    answer.at(6, 11) = r3 / 2. * a2 * ( hky.at(2) * V12.at(1) + hky.at(2) * V12.at(2) );

    answer.at(6, 13) = hky.at(3);
    answer.at(6, 14) = hkx.at(3);
    answer.at(6, 16) = -r3 / 2. * a3 * ( hkx.at(3) * V23.at(2) + hky.at(3) * V23.at(1) );
    answer.at(6, 17) = r3 / 2. * a3 * ( hky.at(3) * V13.at(1) + hky.at(3) * V13.at(2) );

    answer.at(6, 19) = hky.at(4);
    answer.at(6, 20) = hkx.at(4);
    answer.at(6, 22) = -r3 / 2. * a4 * ( hkx.at(4) * V24.at(2) + hky.at(4) * V24.at(1) );
    answer.at(6, 23) = r3 / 2. * a4 * ( hky.at(4) * V14.at(1) + hky.at(4) * V14.at(2) );

	BMatrices.at(gp->giveNumber() - 1).reset(new FloatMatrix(answer));
}

//void
//MITC4Shell :: giveInternalForcesVector(FloatArray &answer,
//    TimeStep *tStep, int useUpdatedGpRecord)
//{
//	FloatMatrix stiffness;
//	FloatArray u;
//
//	this->computeStiffnessMatrix(stiffness, SecantStiffness, tStep);
//	this->computeVectorOf(VM_Total, tStep, u);
//	answer.beProductOf(stiffness, u);
//
//}

std::array<double, 4>
MITC4Shell :: giveThickness()
{
    const auto &c1 = this->giveNode(1)->giveCoordinates();
    const auto &c2 = this->giveNode(2)->giveCoordinates();
    const auto &c3 = this->giveNode(3)->giveCoordinates();
    const auto &c4 = this->giveNode(4)->giveCoordinates();

    return {
        this->giveCrossSection()->give(CS_Thickness, c1, this, false),
        this->giveCrossSection()->give(CS_Thickness, c2, this, false),
        this->giveCrossSection()->give(CS_Thickness, c3, this, false),
        this->giveCrossSection()->give(CS_Thickness, c4, this, false),
    };
}


void
MITC4Shell :: postInitialize()
{
    NLStructuralElement :: postInitialize();

    auto e = this->computeLocalBaseVectors();

        for ( int i = 1; i <= 3; i++ ) {
        GtoLRotationMatrix.at(1, i) = e[0].at(i);
        GtoLRotationMatrix.at(2, i) = e[1].at(i);
        GtoLRotationMatrix.at(3, i) = e[2].at(i);
        }
    }

<<<<<<< .mine
    return & GtoLRotationMatrix;
}

void
MITC4Shell :: computeLocalBaseVectors(FloatArray &e1, FloatArray &e2, FloatArray &e3)
=======
std::array<FloatArrayF<3>, 3>
MITC4Shell :: computeLocalBaseVectors()



>>>>>>> .theirs
{
<<<<<<< .mine
    FloatArray help;
     FloatArray coordA, coordB;
	
    // compute A - (node2+node3)/2
    coordA.beDifferenceOf( * this->giveNode(2)->giveCoordinates(), * this->giveNode(3)->giveCoordinates() );
    coordA.times(0.5);
    coordA.add( * this->giveNode(3)->giveCoordinates() );

    // compute B - (node1+node4)/2
    coordB.beDifferenceOf( * this->giveNode(1)->giveCoordinates(), * this->giveNode(4)->giveCoordinates() );
    coordB.times(0.5);
    coordB.add( * this->giveNode(4)->giveCoordinates() );

=======
    // compute A - (node2+node3)/2
    auto coordA = 0.5 * ( FloatArrayF<3>(this->giveNode(2)->giveCoordinates()) + FloatArrayF<3>(this->giveNode(3)->giveCoordinates()) );
    // compute B - (node1+node4)/2
    auto coordB = 0.5 * ( FloatArrayF<3>(this->giveNode(1)->giveCoordinates()) + FloatArrayF<3>(this->giveNode(4)->giveCoordinates()) );









>>>>>>> .theirs
    // compute e1' = [B-A]
    auto e1 = normalize(coordB - coordA);
	// as in gui
	// e1.beDifferenceOf(*this->giveNode(2)->giveCoordinates(), *this->giveNode(1)->giveCoordinates());

<<<<<<< .mine
	//if (la1.computeNorm() != 0) {
	//	// custom local axes
	//	e1 = la1;
	//}
=======
    // compute A - (node3+node4)/2
    auto coordC = 0.5 * ( FloatArrayF<3>(this->giveNode(4)->giveCoordinates()) + FloatArrayF<3>(this->giveNode(3)->giveCoordinates()) );
    // compute B - (node2+node1)/2
    auto coordD = 0.5 * ( FloatArrayF<3>(this->giveNode(1)->giveCoordinates()) + FloatArrayF<3>(this->giveNode(2)->giveCoordinates()) );
>>>>>>> .theirs

<<<<<<< .mine
    // compute A - (node3+node4)/2
    coordA.beDifferenceOf( * this->giveNode(4)->giveCoordinates(), * this->giveNode(3)->giveCoordinates() );
    coordA.times(0.5);
    coordA.add( * this->giveNode(3)->giveCoordinates() );

    // compute B - (node2+node1)/2
    coordB.beDifferenceOf( * this->giveNode(1)->giveCoordinates(), * this->giveNode(2)->giveCoordinates() );
    coordB.times(0.5);
    coordB.add( * this->giveNode(2)->giveCoordinates() );

    // compute help = [B-A]
    help.beDifferenceOf(coordB, coordA);
	// as in gui
	// help.beDifferenceOf(*this->giveNode(3)->giveCoordinates(), *this->giveNode(1)->giveCoordinates());

    // let us normalize e1'
    e1.normalize();

=======
    // compute help = [D-C]
    auto help = coordD - coordC;
















>>>>>>> .theirs
    // compute e3' : vector product of e1' x help
    auto e3 = normalize(cross(e1, help));
    // now from e3' x e1' compute e2'
    auto e2 = cross(e3, e1);
    return {e1, e2, e3};

	if (la1.computeNorm() != 0) {
		// rotate as to have the 1st local axis equal to la1
		ang = -Angle::giveAngleIn3Dplane(la1, e1, e3); // radians
		e1 = Angle::rotate(e1, e3, ang);
		e2 = Angle::rotate(e2, e3, ang);
	}
}

<<<<<<< .mine
void
MITC4Shell :: computeLToDirectorRotationMatrix(FloatMatrix &answer1, FloatMatrix &answer2, FloatMatrix &answer3, FloatMatrix &answer4)
// Returns the rotation matrix of the reciever of the size [3,3]
=======
std::array<FloatMatrixF<3,3>, 4>
MITC4Shell :: computeLToDirectorRotationMatrix()
// Returns the rotation matrix of the reciever of the size [3,3]
>>>>>>> .theirs
// {alpha_i,beta_i} = Ti * {rotL_xi, rotL_yi, rotL_zi}
//      alpha_i, beta_i - rotations about the components of director vector at node i
//      r1_i, r2_i, r3_i, - rotations about local coordinates e1', e2', e3'
//
// local coordinate (described by vector triplet e1',e2',e3') is defined as follows:
//
// e1'    : [N4-N3]    Ni - means i - th node
// help   : [N2-N3]
// e3'    : e1' x help
// e2'    : e3' x e1'
{
<<<<<<< .mine
	answer1.resize(3, 3);
	answer2.resize(3, 3);
	answer3.resize(3, 3);
	answer4.resize(3, 3);

	if (LMatrices.at(0).get() != nullptr){
		answer1.add(*LMatrices.at(0));
		answer2.add(*LMatrices.at(1));
		answer3.add(*LMatrices.at(2));
		answer4.add(*LMatrices.at(3));
		return;
	}

    FloatArray e1, e2, e3;
=======
    //auto [e1, e2, e3, e4] = this->computeLocalBaseVectors();
    auto e = this->computeLocalBaseVectors();
    auto V = this->giveDirectorVectors();











>>>>>>> .theirs

    std::array<FloatMatrixF<3,3>, 4> answer;
    for (int i = 0; i < 4; ++i) {
        auto Ve = normalize(cross(e[1], V[i]));
        auto VV = cross(V[i], Ve);

        answer[i].at(1, 1) = dot(Ve, e[0]);
        answer[i].at(1, 2) = dot(Ve, e[1]);
        answer[i].at(1, 3) = dot(Ve, e[2]);

        answer[i].at(2, 1) = dot(VV, e[0]);
        answer[i].at(2, 2) = dot(VV, e[1]);
        answer[i].at(2, 3) = dot(VV, e[2]);

<<<<<<< .mine
    V21.beVectorProductOf(V1, V11);
    V22.beVectorProductOf(V2, V12);
    V23.beVectorProductOf(V3, V13);
    V24.beVectorProductOf(V4, V14);

    answer1.at(1, 1) = V11.dotProduct(e1);
    answer1.at(1, 2) = V11.dotProduct(e2);
    answer1.at(1, 3) = V11.dotProduct(e3);
    answer1.at(2, 1) = V21.dotProduct(e1);
    answer1.at(2, 2) = V21.dotProduct(e2);
    answer1.at(2, 3) = V21.dotProduct(e3);
    answer1.at(3, 1) = V1.dotProduct(e1);
    answer1.at(3, 2) = V1.dotProduct(e2);
    answer1.at(3, 3) = V1.dotProduct(e3);

    answer2.at(1, 1) = V12.dotProduct(e1);
    answer2.at(1, 2) = V12.dotProduct(e2);
    answer2.at(1, 3) = V12.dotProduct(e3);
    answer2.at(2, 1) = V22.dotProduct(e1);
    answer2.at(2, 2) = V22.dotProduct(e2);
    answer2.at(2, 3) = V22.dotProduct(e3);
    answer2.at(3, 1) = V2.dotProduct(e1);
    answer2.at(3, 2) = V2.dotProduct(e2);
    answer2.at(3, 3) = V2.dotProduct(e3);

    answer3.at(1, 1) = V13.dotProduct(e1);
    answer3.at(1, 2) = V13.dotProduct(e2);
    answer3.at(1, 3) = V13.dotProduct(e3);
    answer3.at(2, 1) = V23.dotProduct(e1);
    answer3.at(2, 2) = V23.dotProduct(e2);
    answer3.at(2, 3) = V23.dotProduct(e3);
    answer3.at(3, 1) = V3.dotProduct(e1);
    answer3.at(3, 2) = V3.dotProduct(e2);
    answer3.at(3, 3) = V3.dotProduct(e3);

    answer4.at(1, 1) = V14.dotProduct(e1);
    answer4.at(1, 2) = V14.dotProduct(e2);
    answer4.at(1, 3) = V14.dotProduct(e3);
    answer4.at(2, 1) = V24.dotProduct(e1);
    answer4.at(2, 2) = V24.dotProduct(e2);
    answer4.at(2, 3) = V24.dotProduct(e3);
    answer4.at(3, 1) = V4.dotProduct(e1);
    answer4.at(3, 2) = V4.dotProduct(e2);
    answer4.at(3, 3) = V4.dotProduct(e3);
=======
        answer[i].at(3, 1) = dot(V[i], e[0]);
        answer[i].at(3, 2) = dot(V[i], e[1]);
        answer[i].at(3, 3) = dot(V[i], e[2]);









































>>>>>>> .theirs

	LMatrices.at(0).reset(new FloatMatrix(answer1));
	LMatrices.at(1).reset(new FloatMatrix(answer2));
	LMatrices.at(2).reset(new FloatMatrix(answer3));
	LMatrices.at(3).reset(new FloatMatrix(answer4));
}
    return answer;
}

bool
MITC4Shell :: computeGtoLRotationMatrix(FloatMatrix &answer)
// Returns the rotation matrix of the receiver of the size [24,24]
// r(local) = T * r(global)
// for one node (r written transposed): {u,v,w,alpha,beta} = T * {u,v,w,r1,r2,r3}
{
    auto LtoDir = this->computeLToDirectorRotationMatrix();

    answer.resize(24, 24);
    answer.zero();

    for ( int i = 0; i <= 3; i++ ) {
        answer.setSubMatrix(GtoLRotationMatrix, i * 6 + 1, i * 6 + 1);
        auto help = dot(LtoDir[i], GtoLRotationMatrix);
        answer.setSubMatrix(help, i * 6 + 4, i * 6 + 4);
    }

    return 1;
}


void
MITC4Shell :: computeStressVector(FloatArray &answer, const FloatArray &strain, GaussPoint *gp, TimeStep *tStep)
{
    answer = this->giveStructuralCrossSection()->giveRealStress_3dDegeneratedShell(strain, gp, tStep);
}


<<<<<<< .mine
void
MITC4Shell::computeStiffnessMatrix(FloatMatrix &answer, MatResponseMode rMode, TimeStep *tStep)
{
	// assemble from parent
	NLStructuralElement::computeStiffnessMatrix(answer, rMode, tStep);

	// NF mod - use drilling from section input
	FloatArray n;
	FloatMatrix drillStiffness;
	bool drillCoeffFlag = false;

	for (GaussPoint *gp : *integrationRulesArray[0]) {
		double dV = this->computeVolumeAround(gp);
		double drillCoeff = this->giveStructuralCrossSection()->give(CS_DrillingStiffness, gp);

		// Drilling stiffness is here for improved numerical properties
		if (drillCoeff > 0.) {
			this->interp_lin.evalN(n, gp->giveNaturalCoordinates(), FEIVoidCellGeometry());
			for (int j = 0; j < 4; j++) {
				n(j) -= 0.25;
			}
			drillStiffness.plusDyadSymmUpper(n, drillCoeff * dV);
			drillCoeffFlag = true;
		}
	}

	if (drillCoeffFlag) {
		drillStiffness.symmetrized();
		answer.assemble(drillStiffness, this->drillOrdering);
	}
}


void
MITC4Shell::giveInternalForcesVector(FloatArray &answer, TimeStep *tStep, int useUpdatedGpRecord)
{
	// This element adds an additional stiffness for the so called drilling dofs.
	NLStructuralElement::giveInternalForcesVector(answer, tStep, useUpdatedGpRecord);

	FloatArray tmp; 
	FloatArray n, drillUnknowns, drillMoment;
	bool drillCoeffFlag = false;
	this->computeVectorOf(VM_Total, tStep, tmp);
	drillUnknowns.beSubArrayOf(tmp, this->drillOrdering);

    // Drilling stiffness is here for improved numerical properties
	for (GaussPoint *gp : *integrationRulesArray[0]) {
		double dV = this->computeVolumeAround(gp);
		drillCoeff = this->giveStructuralCrossSection()->give(CS_DrillingStiffness, gp);

		// Drilling stiffness is here for improved numerical properties
		if (drillCoeff > 0.) {
			this->interp_lin.evalN(n, gp->giveNaturalCoordinates(), FEIVoidCellGeometry());
			for (int j = 0; j < 4; j++) {
				n(j) -= 0.25;
			}
			double dtheta = n.dotProduct(drillUnknowns);
			drillMoment.add(drillCoeff * dV * dtheta, n); ///@todo Decide on how to alpha should be defined.
			drillCoeffFlag = true;
		}
	}

	if (drillCoeffFlag) {
		answer.assemble(drillMoment, this->drillOrdering);
	}
}


void
MITC4Shell :: giveCharacteristicTensor(FloatMatrix &answer, CharTensor type, GaussPoint *gp, TimeStep *tStep)
// returns characteristic tensor of the receiver at given gp and tStep
=======
FloatMatrix
MITC4Shell :: giveCharacteristicTensor(CharTensor type, GaussPoint *gp, TimeStep *tStep)





































































>>>>>>> .theirs
{
<<<<<<< .mine
    answer.resize(3, 3);
    answer.zero();
    this->computeGtoLRotationMatrix();
    StructuralMaterial *mat = static_cast< StructuralMaterial * >( this->giveStructuralCrossSection()->giveMaterial(gp) );
=======
    auto mat = dynamic_cast< StructuralMaterial * >( this->giveStructuralCrossSection()->giveMaterial(gp) );



>>>>>>> .theirs

    if ( type == GlobalForceTensor ) {
        FloatArray localStress, localStrain;
        this->computeStrainVector(localStrain, gp, tStep);
        this->computeStressVector(localStress, localStrain, gp, tStep);
<<<<<<< .mine
        mat->transformStressVectorTo(stress,  GtoLRotationMatrix, localStress, false);

        answer.at(1, 1) = stress.at(1);
        answer.at(2, 2) = stress.at(2);
        answer.at(3, 3) = stress.at(3);
		answer.at(2, 3) = stress.at(4);
		answer.at(3, 2) = stress.at(4);
		answer.at(1, 3) = stress.at(5);
		answer.at(3, 1) = stress.at(5);
		answer.at(1, 2) = stress.at(6);
		answer.at(2, 1) = stress.at(6);
    } else if ( ( type == GlobalStrainTensor ) ) {
=======
        auto stress = mat->transformStressVectorTo(GtoLRotationMatrix, localStress, false);
        return from_voigt_stress(stress);
    } else if ( type == GlobalStrainTensor ) {









>>>>>>> .theirs
        FloatArray localStrain;
        this->computeStrainVector(localStrain, gp, tStep);
        auto strain = mat->transformStrainVectorTo(GtoLRotationMatrix, localStrain, false);
        return from_voigt_strain(strain);
    } else {
        throw std::runtime_error("unsupported tensor mode");
        exit(1);
    }
}

void
MITC4Shell :: printOutputAt(FILE *file, TimeStep *tStep)
// Performs end-of-step operations.
{
	fprintf(file, "element %d (%8d) macroelem %d :\n", this->giveLabel(), number,this->macroElem);

#ifdef DEBUG
	FloatArray v;
<<<<<<< .mine
	GaussPoint *gp;

=======


>>>>>>> .theirs
    for ( int i = 0; i < nPointsXY; i++ ) {
        fprintf(file, "  GP %d :", i + 1);

<<<<<<< .mine
        this->giveMidplaneIPValue(v, i, IST_ShellForceTensor, tStep);
        fprintf(file, "  forces     ");




























=======
    for ( int i = 0; i < nPointsXY; i++ ) {
        fprintf(file, "  GP %d :", i + 1);

        fprintf(file, "  forces     ");
        for ( auto &val : this->giveMidplaneIPValue(i, IST_ShellForceTensor, tStep) ) {
            fprintf(file, " %.4e", val);
        }

        fprintf(file, "\n          moments    ");
        for ( auto &val : this->giveMidplaneIPValue(i, IST_ShellMomentTensor, tStep) ) {
            fprintf(file, " %.4e", val);
        }

        fprintf(file, "\n          strains    ");
        for ( auto &val : this->giveMidplaneIPValue(i, IST_ShellStrainTensor, tStep) ) {
            fprintf(file, " %.4e", val);
        }

        fprintf(file, "\n          curvatures ");
        for ( auto &val : this->giveMidplaneIPValue(i, IST_CurvatureTensor, tStep) ) {
            fprintf(file, " %.4e", val);
        }

        for ( int j = 0; j < nPointsZ; j++ ) {
            auto gp = integrationRulesArray [ 0 ]->getIntegrationPoint(nPointsZ * i + j);

            fprintf(file, "\n          GP %d.%d :", i + 1, j + 1);

            this->giveIPValue(v, gp, IST_StrainTensor, tStep);
            fprintf(file, "    strains    ");
>>>>>>> .theirs
        for ( auto &val : v ) {
            fprintf(file, " %.4e", val);
        }

<<<<<<< .mine
        this->giveMidplaneIPValue(v, i, IST_ShellMomentTensor, tStep);
        fprintf(file, "\n          moments    ");
=======
            this->giveIPValue(v, gp, IST_StressTensor, tStep);
            fprintf(file, "\n                      stresses   ");
>>>>>>> .theirs
        for ( auto &val : v ) {
            fprintf(file, " %.4e", val);
        }
        }
        this->giveMidplaneIPValue(v, i, IST_ShellStrainTensor, tStep);
        fprintf(file, "\n          strains    ");
        for ( auto &val : v ) {
            fprintf(file, " %.4e", val);
        }

        this->giveMidplaneIPValue(v, i, IST_CurvatureTensor, tStep);
        fprintf(file, "\n          curvatures ");
        for ( auto &val : v ) {
            fprintf(file, " %.4e", val);
        }

        //for ( int j = 0; j < nPointsZ; j++ ) {
        //    gp = integrationRulesArray [ 0 ]->getIntegrationPoint(nPointsZ * i + j);

        //    fprintf(file, "\n          GP %d.%d :", i + 1, j + 1);

        //    this->giveIPValue(v, gp, IST_StrainTensor, tStep);
        //    fprintf(file, "    strains    ");
        //    for ( auto &val : v ) {
        //        fprintf(file, " %.4e", val);
        //    }

        //    this->giveIPValue(v, gp, IST_StressTensor, tStep);
        //    fprintf(file, "\n                      stresses   ");
        //    for ( auto &val : v ) {
        //        fprintf(file, " %.4e", val);
        //    }
        //}
        fprintf(file, "\n");
    }
#endif
}

<<<<<<< .mine
void
MITC4Shell :: giveMidplaneIPValue(FloatArray &answer, int gpXY, InternalStateType type, TimeStep *tStep)
=======
FloatArray
MITC4Shell :: giveMidplaneIPValue(int gpXY, InternalStateType type, TimeStep *tStep)
>>>>>>> .theirs
{
<<<<<<< .mine
    GaussPoint *gp = NULL;
	answer.zero();
=======
    if ( type == IST_ShellMomentTensor || type == IST_ShellForceTensor ) {
        FloatArrayF<6> mLocal;
>>>>>>> .theirs

<<<<<<< .mine
//#ifdef DEBUG
//	// debug
//	if (this->number == 73) {
//		printf("stop");
//	}
//#endif





=======
        for ( int i = 0; i < nPointsZ; i++ ) {
            auto gp = integrationRulesArray [ 0 ]->getIntegrationPoint(nPointsZ * gpXY + i);
            double thickness = this->giveCrossSection()->give(CS_Thickness, gp->giveGlobalCoordinates(), this, false);
            double J = thickness / 2.0;
            double z;
            if (  type == IST_ShellMomentTensor ) {
                z = gp->giveNaturalCoordinates().at(3) * ( thickness / 2 );
            } else /*if (  type == IST_ShellForceTensor )*/ {
                z = 1;
            }
            double w = gp->giveWeight() * J * z;
>>>>>>> .theirs

<<<<<<< .mine
    if ( type == IST_ShellMomentTensor || type == IST_ShellForceTensor ) {
        double J, thickness, z, w;
        FloatArray mLocal;
        mLocal.resize(6);
        mLocal.zero();
=======
            FloatArray localStress, localStrain;
            this->computeStrainVector(localStrain, gp, tStep);
            this->computeStressVector(localStress, localStrain, gp, tStep);
            mLocal += w * FloatArrayF<6>(localStress);
        }
>>>>>>> .theirs

<<<<<<< .mine
        for ( int i = 0; i < nPointsZ; i++ ) {
            gp = integrationRulesArray [ 0 ]->getIntegrationPoint(nPointsZ * gpXY + i);
            thickness = this->giveCrossSection()->give(CS_Thickness, gp->giveGlobalCoordinates(), this, false);
            J = thickness / 2.0;
            if (  type == IST_ShellMomentTensor ) {
                z = gp->giveNaturalCoordinates().at(3) * J;
			} else {
				 // if (type == IST_ShellForceTensor) { // to remove warning
                z = 1;
            }
            w = gp->giveWeight() * J * z;
=======
        // local to global
        return StructuralMaterial::transformStressVectorTo(GtoLRotationMatrix, mLocal, false);
    } else if ( type == IST_CurvatureTensor ) {
        auto gp = integrationRulesArray [ 0 ]->getIntegrationPoint(nPointsZ * gpXY);
        const auto &coords = gp->giveNaturalCoordinates();






>>>>>>> .theirs

<<<<<<< .mine
            FloatArray localStress, localStrain;
            this->computeStrainVector(localStrain, gp, tStep);
            this->computeStressVector(localStress, localStrain, gp, tStep);
            mLocal.add(w, localStress);
        }

		if (type == IST_ShellMomentTensor) { mLocal.negated(); } // tension at bottom is positive bending
		// local to global
		this->computeGtoLRotationMatrix();
		StructuralMaterial::transformStressVectorTo(answer, GtoLRotationMatrix, mLocal, false);
    } else if ( type == IST_CurvatureTensor ) {
        FloatArray h;
        FloatMatrix dn;
        FloatArray coords;

        gp = integrationRulesArray [ 0 ]->getIntegrationPoint(nPointsZ * gpXY);
        coords = gp->giveNaturalCoordinates();
        FloatArray hkx, hky;
        this->givedNdx(hkx, hky, coords);

        FloatArray dofs(24);


        FloatArray rotX(4), rotY(4);

        this->computeVectorOf(VM_Total, tStep, dofs);
        for ( int i = 0; i < 4; i++ ) {
            rotX(i) = dofs.at(i * 6 + 4);
            rotY(i) = dofs.at(i * 6 + 5);
        }
        FloatArray cLocal(6);
        cLocal.zero();
        cLocal.at(1) = rotY.dotProduct(hkx);
        cLocal.at(2) = -rotX.dotProduct(hky);
        cLocal.at(6) = rotY.dotProduct(hky) - rotX.dotProduct(hkx);
		cLocal.negated(); // tension at bottom is positive bending
		StructuralMaterial::transformStrainVectorTo(answer, GtoLRotationMatrix, cLocal, false);
    } else if ( type == IST_ShellStrainTensor ) {
        FloatArray coords;
        gp = integrationRulesArray [ 0 ]->getIntegrationPoint(nPointsZ * gpXY);
        coords = gp->giveNaturalCoordinates();
        coords.at(3) = 0;     //set to midplane
        IntegrationRule *iRule = new GaussIntegrationRule(1, this, 1, 10);
        GaussPoint *midGP = new GaussPoint( iRule, 1, coords, 1, this->giveMaterialMode() );

        // this->giveIPValue(answer, midGP, IST_StrainTensor, tStep);
		FloatMatrix globTensor;
		CharTensor cht;

		cht = GlobalStrainTensor;
		this->giveCharacteristicTensor(globTensor, cht, gp, tStep);
		answer.at(1) = globTensor.at(1, 1); //xx
		answer.at(2) = globTensor.at(2, 2); //yy
		answer.at(3) = globTensor.at(3, 3); //zz
		answer.at(4) = 2 * globTensor.at(2, 3); //yz
		answer.at(5) = 2 * globTensor.at(1, 3); //xz
		answer.at(6) = 2 * globTensor.at(1, 2); //xy
=======
        //auto [hkx, hky] = this->givedNdx(coords);
        auto hk = this->givedNdx(coords);























































>>>>>>> .theirs
    } else {
        OOFEM_ERROR("MITC4Shell :: giveMidplaneIPValue - unknown type");
    }

<<<<<<< .mine
    return;
}
=======
        FloatArray dofs(24);
        this->computeVectorOf(VM_Total, tStep, dofs);
>>>>>>> .theirs

<<<<<<< .mine
void
MITC4Shell :: givedNdx(FloatArray &hkx, FloatArray &hky, FloatArray coords)
{
    FloatArray h, hk1(4), hk2(4);
    FloatMatrix dn, dndx, jacobianMatrix, inv, inv2;




=======
        FloatArrayF<4> rotX, rotY;
        for ( int i = 0; i < 4; i++ ) {
            rotX[i] = dofs.at(i * 6 + 4);
            rotY[i] = dofs.at(i * 6 + 5);
        }
        FloatArrayF<6> cLocal;
        cLocal.at(1) = dot(rotY, hk[0]);
        cLocal.at(2) = -dot(rotX, hk[1]);
        cLocal.at(6) = dot(rotY, hk[1]) - dot(rotX, hk[0]);
>>>>>>> .theirs

<<<<<<< .mine
    interp_lin.evalN( h, coords,  FEIElementGeometryWrapper(this) );
    interp_lin.giveDerivatives(dn, coords);





=======
        return StructuralMaterial::transformStrainVectorTo(GtoLRotationMatrix, cLocal, false);
    } else if ( type == IST_ShellStrainTensor ) {
        auto gp = integrationRulesArray [ 0 ]->getIntegrationPoint(nPointsZ * gpXY);
        auto coords = gp->giveNaturalCoordinates();
        coords.at(3) = 0.; //set to midplane
        GaussIntegrationRule iRule(1, this, 1, 10);
        GaussPoint midGP( &iRule, 1, coords, 1, this->giveMaterialMode() );
>>>>>>> .theirs

<<<<<<< .mine
    // derivatives of interpolation functions
    // dh(r1,r2)/dr1
    hk1.at(1) =  dn.at(1, 1);
    hk1.at(2) =  dn.at(2, 1);
    hk1.at(3) =  dn.at(3, 1);
    hk1.at(4) =  dn.at(4, 1);

    // dh(r1,r2)/dr2
    hk2.at(1) =  dn.at(1, 2);
    hk2.at(2) =  dn.at(2, 2);
    hk2.at(3) =  dn.at(3, 2);
    hk2.at(4) =  dn.at(4, 2);

    // Jacobian Matrix
    this->giveJacobian(coords, jacobianMatrix);
    inv.beInverseOf(jacobianMatrix);

    inv2.beSubMatrixOf(inv, 1, 2, 1, 2);
    dndx.beProductTOf(dn, inv2);

    hkx.resize(4);
    hkx.at(1)  = dndx.at(1, 1);
    hkx.at(2)  = dndx.at(2, 1);
    hkx.at(3)  = dndx.at(3, 1);
    hkx.at(4)  = dndx.at(4, 1);

    hky.resize(4);
    hky.at(1)  = dndx.at(1, 2);
    hky.at(2)  = dndx.at(2, 2);
    hky.at(3)  = dndx.at(3, 2);
    hky.at(4)  = dndx.at(4, 2);

    return;
}

void
MITC4Shell::setupIRForMassMtrxIntegration(IntegrationRule &iRule)
{
	iRule.setUpIntegrationPoints(this->giveIntegrationDomain(), nPointsXY, nPointsZ, this->giveMaterialMode());
}

int
MITC4Shell :: giveIPValue(FloatArray &answer, GaussPoint *gp, InternalStateType type, TimeStep *tStep)
{
    FloatMatrix globTensor;
    CharTensor cht;

    answer.resize(6);
	answer.zero();
    if (  type == IST_StrainTensor ) {
  //      cht = GlobalStrainTensor;
		//this->giveCharacteristicTensor(globTensor, cht, gp, tStep);
		//answer.at(1) = globTensor.at(1, 1); //xx
  //      answer.at(2) = globTensor.at(2, 2); //yy
  //      answer.at(3) = globTensor.at(3, 3); //zz
  //      answer.at(4) = 2 * globTensor.at(2, 3); //yz
  //      answer.at(5) = 2 * globTensor.at(1, 3); //xz
  //      answer.at(6) = 2 * globTensor.at(1, 2); //xy

=======
        FloatArray answer;
        this->giveIPValue(answer, &midGP, IST_StrainTensor, tStep);
        return answer;
    } else {
        throw std::runtime_error("unknown type");
    }
}

std::array<FloatArrayF<4>, 2>
MITC4Shell :: givedNdx(const FloatArrayF<3> &coords)
{
    auto dn = interp_lin.evaldNdxi(coords[{0, 1}]);
    auto J = this->giveJacobian(coords);
    auto invJ = inv(J);
    auto invJ2 = invJ({0, 1}, {0, 1});
    auto dndx = dot(invJ2, dn);

    auto hkx = dndx.row<0>();
    auto hky = dndx.row<1>();
    return {hkx, hky};
}

void
MITC4Shell :: setupIRForMassMtrxIntegration(IntegrationRule &iRule)
{
    iRule.setUpIntegrationPoints( this->giveIntegrationDomain(), nPointsXY, nPointsZ, this->giveMaterialMode() );
}

int
MITC4Shell :: giveIPValue(FloatArray &answer, GaussPoint *gp, InternalStateType type, TimeStep *tStep)
{
    if ( type == IST_StrainTensor ) {
        auto globTensor = this->giveCharacteristicTensor(GlobalStrainTensor, gp, tStep);
        answer = to_voigt_strain(globTensor);

























>>>>>>> .theirs
        return 1;
<<<<<<< .mine
    } else if ( type == IST_StressTensor ) {
        //cht = GlobalForceTensor;
        //this->giveCharacteristicTensor(globTensor, cht, gp, tStep);
        //answer.at(1) = globTensor.at(1, 1); //xx
        //answer.at(2) = globTensor.at(2, 2); //yy
        //answer.at(3) = globTensor.at(3, 3); //zz
        //answer.at(4) = globTensor.at(2, 3); //yz
        //answer.at(5) = globTensor.at(1, 3); //xz
        //answer.at(6) = globTensor.at(1, 2); //xy

        return 1;
    } else if ( type == IST_ShellMomentTensor || type == IST_ShellForceTensor || type == IST_CurvatureTensor || type == IST_ShellStrainTensor ) {
        int gpnXY = ( gp->giveNumber() - 1 ) / nPointsZ;
        this->giveMidplaneIPValue(answer, gpnXY, type, tStep);

        return 1;
=======
    } else if ( type == IST_StressTensor ) {
        auto globTensor = this->giveCharacteristicTensor(GlobalForceTensor, gp, tStep);
        answer = to_voigt_stress(globTensor);
        return 1;
    } else if ( type == IST_ShellMomentTensor || type == IST_ShellForceTensor || type == IST_CurvatureTensor || type == IST_ShellStrainTensor ) {
        int gpnXY = ( gp->giveNumber() - 1 ) / 2;
        answer = this->giveMidplaneIPValue(gpnXY, type, tStep);

        return 1;







>>>>>>> .theirs
    } else {
        return NLStructuralElement :: giveIPValue(answer, gp, type, tStep);
    }
}


bool
MITC4Shell :: computeLocalCoordinates(FloatArray &answer, const FloatArray &coords)
//converts global coordinates to local planar area coordinates,
//does not return a coordinate in the thickness direction, but
//does check that the point is in the element thickness
{
    // rotate the input point Coordinate System into the element CS
    FloatArray llc;
    auto inputCoords_ElCS = this->giveLocalCoordinates(coords);
    std :: vector< FloatArray >lc(3);
    for ( int _i = 0; _i < 4; _i++ ) {
        lc [ _i ] = this->giveLocalCoordinates(this->giveNode(_i + 1)->giveCoordinates());
    }
    bool inplane = interp_lin.global2local( llc, inputCoords_ElCS, FEIVertexListGeometryWrapper(lc) ) > 0;
    answer.resize(2);
    answer.at(1) = inputCoords_ElCS.at(1);
    answer.at(2) = inputCoords_ElCS.at(2);
    GaussPoint _gp(nullptr, 1, answer, 2.0, _2dPlate);
    // now check if the third local coordinate is within the thickness of element
    bool outofplane = ( fabs( inputCoords_ElCS.at(3) ) <= this->giveCrossSection()->give(CS_Thickness, & _gp) / 2. );

    return inplane && outofplane;
}



int
MITC4Shell :: computeGlobalCoordinates(FloatArray &answer, const FloatArray &lcoords)
{
<<<<<<< .mine
    //double l1 = lcoords.at(1);
    //double l2 = lcoords.at(2);
    //double l3 = lcoords.at(3);
    FloatMatrix N;
=======
    FloatMatrix N;
    computeNmatrixAt(lcoords, N);


>>>>>>> .theirs
    
    computeNmatrixAt(lcoords, N);

    answer.resize(3);
    for ( int _i = 1; _i <= 3; _i++ ) {
        answer.at(_i) = N.at(_i,_i) * this->giveNode(1)->giveCoordinate(_i) + N.at(_i,_i+6) *this->giveNode(2)->giveCoordinate(_i) + N.at(_i,_i+12)*this->giveNode(3)->giveCoordinate(_i) + N.at(_i,_i+18)*this->giveNode(4)->giveCoordinate(_i);
    }
    return true;
}


int
MITC4Shell :: computeLoadGToLRotationMtrx(FloatMatrix &answer)
// Returns the rotation matrix of the receiver of the size [5,6]
// f(local) = T * f(global)
{
    answer.resize(6, 6);
    answer.zero();

    for ( int i = 1; i <= 3; i++ ) {
        answer.at(1, i) = answer.at(4, i + 3) = GtoLRotationMatrix.at(1, i);
        answer.at(2, i) = answer.at(5, i + 3) = GtoLRotationMatrix.at(2, i);
        answer.at(3, i) = answer.at(6, i + 3) = GtoLRotationMatrix.at(3, i);
    }

    return 1;
}


void
MITC4Shell :: NodalAveragingRecoveryMI_computeNodalValue(FloatArray &answer, int node,
                                                         InternalStateType type, TimeStep *tStep)
{
<<<<<<< .mine


=======
    FloatMatrixF<3,3> A;
    std::vector<FloatArrayF<3>> r;
>>>>>>> .theirs
    FloatArray val;
	int size = 0;
<<<<<<< .mine

 //   double u, v;
 //   double x1 = 0.0, x2 = 0.0, y = 0.0;
 //   FloatMatrix b, r;
 //   FloatMatrix A(3, 3);
 //   for ( GaussPoint *gp : *integrationRulesArray [ 0 ] ) {
 //       giveIPValue(val, gp, type, tStep);
 //       if ( size == 0 ) {
 //           size = val.giveSize();
 //           b.resize(3, size);
 //           r.resize(3, size);
 //           A.zero();
 //           r.zero();
 //       }
=======
    for ( GaussPoint *gp : *integrationRulesArray [ 0 ] ) {
        giveIPValue(val, gp, type, tStep);
        if ( size == 0 ) {
            size = val.giveSize();
            r.resize(size);
        }








>>>>>>> .theirs

<<<<<<< .mine
 //       const FloatArray &coord = gp->giveNaturalCoordinates();
 //       u = coord.at(1);
 //       v = coord.at(2);
=======
        const auto &coord = gp->giveNaturalCoordinates();
        double u = coord.at(1);
        double v = coord.at(2);
>>>>>>> .theirs

<<<<<<< .mine
 //       A.at(1, 1) += 1;
 //       A.at(1, 2) += u;
 //       A.at(1, 3) += v;
 //       A.at(2, 1) += u;
 //       A.at(2, 2) += u * u;
 //       A.at(2, 3) += u * v;
 //       A.at(3, 1) += v;
 //       A.at(3, 2) += v * u;
 //       A.at(3, 3) += v * v;
=======
        A.at(1, 1) += 1;
        A.at(1, 2) += u;
        A.at(1, 3) += v;
        A.at(2, 1) += u;
        A.at(2, 2) += u * u;
        A.at(2, 3) += u * v;
        A.at(3, 1) += v;
        A.at(3, 2) += v * u;
        A.at(3, 3) += v * v;
>>>>>>> .theirs

<<<<<<< .mine
 //       for ( int j = 1; j <= size; j++ ) {
 //           y = val.at(j);
 //           r.at(1, j) += y;
 //           r.at(2, j) += y * u;
 //           r.at(3, j) += y * v;
 //       }
 //   }
=======
        for ( int j = 1; j <= size; j++ ) {
            double y = val.at(j);
            r[j].at(1) += y;
            r[j].at(2) += y * u;
            r[j].at(3) += y * v;
        }
    }
>>>>>>> .theirs

<<<<<<< .mine
 //   A.solveForRhs(r, b);




=======
    auto invA = inv(A);
    std::vector<FloatArrayF<3>> b(size);
    for (int i = 0; i < size; ++i) {
        b[i] = dot(invA, r[i]);
    }
>>>>>>> .theirs

<<<<<<< .mine
	//// no ---------------------------------
 //   //switch ( node ) {
 //   //case 1:
 //   //    x1 = -1.0;
 //   //    x2 = -1.0;
 //   //    break;
 //   //case 2:
 //   //    x1 =  1.0;
 //   //    x2 = -1.0;
 //   //    break;
 //   //case 3:
 //   //    x1 =  1.0;
 //   //    x2 =  1.0;
 //   //    break;
 //   //case 4:
 //   //    x1 = -1.0;
 //   //    x2 =  1.0;
 //   //    break;
 //   //default:
 //   //    OOFEM_ERROR("unsupported node");
 //   //}
	////if (node < 1 || node>4) {
	////	OOFEM_ERROR("unsupported node");
	////}
	//// no ---------------------------------
=======
    double x1 = 0.0, x2 = 0.0;
    switch ( node ) {
    case 1:
        x1 =  1.0;
        x2 =  1.0;
        break;
    case 2:
        x1 = -1.0;
        x2 =  1.0;
        break;
    case 3:
        x1 = -1.0;
        x2 = -1.0;
        break;
    case 4:
        x1 =  1.0;
        x2 = -1.0;
        break;
    default:
        OOFEM_ERROR("unsupported node");
    }




>>>>>>> .theirs

	//switch (node) {
	//case 1:
	//	x1 = 1.0;
	//	x2 = 1.0;
	//	break;
	//case 2:
	//	x1 = -1.0;
	//	x2 = 1.0;
	//	break;
	//case 3:
	//	x1 = -1.0;
	//	x2 = -1.0;
	//	break;
	//case 4:
	//	x1 = 1.0;
	//	x2 = -1.0;
	//	break;
	//default:
	//	OOFEM_ERROR("unsupported node");
	//}

 //   answer.resize(size);
 //   for ( int j = 1; j <= size; j++ ) {
 //       answer.at(j) = b.at(1, j) + x1 *b.at(2, j) + x2 *b.at(3, j);
 //   }

	// compute extrapolation, divide by 2
	size = 0;
	val.zero();
	FloatArray Nweights;
	FEIElementGeometryWrapper wrap(this);
	answer.zero();
	for (GaussPoint *gp : *integrationRulesArray[0]) {
		this->giveIPValue(val, gp, type, tStep);
		if (size == 0) {
			size = val.giveSize();
			answer.resize(size);
<<<<<<< .mine


=======
    for ( int j = 1; j <= size; j++ ) {
        answer.at(j) = b[j].at(1) + x1 * b[j].at(2) + x2 * b[j].at(3);
>>>>>>> .theirs
		}
		interp_lin.evalN(Nweights, gp->giveNaturalCoordinates(), wrap);
		answer.add(Nweights.at(node), val);
	}
<<<<<<< .mine
	answer.times(0.5);
}


void
=======


void


>>>>>>> .theirs
MITC4Shell :: giveEdgeDofMapping(IntArray &answer, int iEdge) const
{
    if ( iEdge == 1 ) { // edge between nodes 1 2
        answer = {
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
        };
    } else if ( iEdge == 2 ) { // edge between nodes 2 3
        answer = {
            7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18
        };
    } else if ( iEdge == 3 ) { // edge between nodes 3 4
        answer = {
            13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24
        };
    } else if ( iEdge == 4 ) { // edge between nodes 4 1
        answer = {
            19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6
        };
    } else {
        OOFEM_ERROR("wrong edge number");
    }
}


double
MITC4Shell :: computeEdgeVolumeAround(GaussPoint *gp, int iEdge)
{
    auto lcF = this->giveNodeCoordinates();
    std :: vector< FloatArray >lc;
    lc[0] = lcF[0];
    lc[1] = lcF[1];
    lc[2] = lcF[2];
    lc[3] = lcF[3];
    double detJ = this->interp_lin.edgeGiveTransformationJacobian( iEdge, gp->giveNaturalCoordinates(), FEIVertexListGeometryWrapper(lc) );
    return detJ * gp->giveWeight();
}

<<<<<<< .mine
/*
 * void
 * MITC4Shell :: computeEdgeIpGlobalCoords(FloatArray &answer, GaussPoint *gp, int iEdge)
 * {
 * std :: vector< FloatArray > lc = {FloatArray(3), FloatArray(3), FloatArray(3), FloatArray(3)};
 * this->giveNodeCoordinates(lc[0].at(1), lc[1].at(1), lc[2].at(1), lc[3].at(1),
 *                          lc[0].at(2), lc[1].at(2), lc[2].at(2), lc[3].at(2),
 *                          lc[0].at(3), lc[1].at(3), lc[2].at(3), lc[3].at(3));
 *
 * FloatArray local;
 * this->interp_lin.edgeLocal2global( local, iEdge, gp->giveNaturalCoordinates(), FEIVertexListGeometryWrapper(lc)  );
 * local.resize(3);
 * local.at(3) = 0.;
 *
 * answer = local; // MITC4 - todo
 * // answer.beProductOf(this->lcsMatrix, local);
 * }
 */
=======
#if 0
void
MITC4Shell :: computeEdgeIpGlobalCoords(FloatArray &answer, GaussPoint *gp, int iEdge)
{
    auto lc = this->giveNodeCoordinates();













>>>>>>> .theirs

int
MITC4Shell :: computeLoadLEToLRotationMatrix(FloatMatrix &answer, int iEdge, GaussPoint *gp)
{
    auto e = this->computeLocalBaseVectors();

    const auto &edgeNodes = this->interp_lin.computeLocalEdgeMapping(iEdge);

    auto n1 = FloatArrayF<3>(this->giveNode( edgeNodes.at(1) )->giveCoordinates());
    auto n2 = FloatArrayF<3>(this->giveNode( edgeNodes.at(2) )->giveCoordinates());

    auto xl = normalize(n1 - n2);
    auto yl = cross(e[2], xl);

    answer.resize(6, 6);
    answer.zero();

    answer.at(1, 1) = answer.at(4, 4) = dot(e[0], xl);
    answer.at(1, 2) = answer.at(4, 5) = dot(e[0], yl);
    answer.at(1, 3) = answer.at(4, 6) = dot(e[0], e[2]);
    answer.at(2, 1) = answer.at(5, 4) = dot(e[1], xl);
    answer.at(2, 2) = answer.at(5, 5) = dot(e[1], yl);
    answer.at(2, 3) = answer.at(5, 6) = dot(e[1], e[2]);
    answer.at(3, 1) = answer.at(6, 4) = dot(e[2], xl);
    answer.at(3, 2) = answer.at(6, 5) = dot(e[2], yl);
    answer.at(3, 3) = answer.at(6, 6) = dot(e[2], e[2]);

    return 1;
}



void
MITC4Shell :: computeSurfaceNMatrixAt(FloatMatrix &answer, int iSurf, GaussPoint *sgp)
{
    const auto &coords2 = sgp->giveNaturalCoordinates();
    FloatArray coords = {coords2[0], coords[1], 0.};
    this->computeNmatrixAt(coords, answer);
}

void
MITC4Shell :: giveSurfaceDofMapping(IntArray &answer, int iSurf) const
{
    int i;
    answer.resize(24);
    answer.zero();
    if ( iSurf == 1 ) {
        for ( i = 1; i <= 24; i++ ) {
            answer.at(i) = i;
        }
    } else {
        OOFEM_ERROR("wrong surface number");
    }
}

<<<<<<< .mine
IntegrationRule *
MITC4Shell :: GetSurfaceIntegrationRule(int approxOrder)
{
    IntegrationRule *iRule = new GaussIntegrationRule(1, this, 1, 1);
    int npoints = iRule->getRequiredNumberOfIntegrationPoints(_Square, approxOrder);
    iRule->SetUpPointsOnSquare(npoints, _Unknown);
    return iRule;
}


=======










>>>>>>> .theirs

double
MITC4Shell :: computeSurfaceVolumeAround(GaussPoint *gp, int iSurf)
{
    FloatArrayF<2> lcoords = {
        gp->giveNaturalCoordinate(1),
        gp->giveNaturalCoordinate(2),
    };

    auto xyz = this->giveNodeCoordinates();
    auto dn = interp_lin.evaldNdxi(lcoords);

    FloatMatrixF<2,2> jacobianMatrix;
    for ( std::size_t i = 0; i < dn.cols(); i++ ) {
        double x = xyz[i][0];
        double y = xyz[i][1];

<<<<<<< .mine
    interp_lin.giveDerivatives(dn, lcoords);




=======
        jacobianMatrix(0, 0) += dn(0, i) * x;
        jacobianMatrix(0, 1) += dn(0, i) * y;
        jacobianMatrix(1, 0) += dn(1, i) * x;
        jacobianMatrix(1, 1) += dn(1, i) * y;
    }
>>>>>>> .theirs

    return det(jacobianMatrix) * gp->giveWeight();
}

void
MITC4Shell :: computeEdgeNMatrix(FloatMatrix &answer, int boundaryID, const FloatArray &lcoords)
{
    FloatArray n_vec;
    this->giveInterpolation()->boundaryEdgeEvalN( n_vec, boundaryID, lcoords, FEIElementGeometryWrapper(this) );
    answer.beNMatrixOf(n_vec, 6);
    }


void
MITC4Shell :: computeSurfaceNMatrix(FloatMatrix &answer, int boundaryID, const FloatArray &lcoords)
{
    FloatArray n_vec;
    this->giveInterpolation()->boundarySurfaceEvalN( n_vec, boundaryID, lcoords, FEIElementGeometryWrapper(this) );
    answer.beNMatrixOf(n_vec, 6);
}

void
MITC4Shell :: computeEdgeNMatrix(FloatMatrix &answer, int boundaryID, const FloatArray &lcoords)
{
    FloatArray n_vec;
    this->giveInterpolation()->boundaryEdgeEvalN( n_vec, boundaryID, lcoords, FEIElementGeometryWrapper(this) );
    answer.beNMatrixOf(n_vec, 6);
}


void
MITC4Shell :: computeSurfaceNMatrix(FloatMatrix &answer, int boundaryID, const FloatArray &lcoords)
{
    FloatArray n_vec;
    this->giveInterpolation()->boundarySurfaceEvalN( n_vec, boundaryID, lcoords, FEIElementGeometryWrapper(this) );
    answer.beNMatrixOf(n_vec, 6);
}


} // end namespace oofem
